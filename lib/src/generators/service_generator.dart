import 'dart:io';

import 'package:build/src/builder/build_step.dart';
import 'package:analyzer/dart/element/element.dart';
import 'package:karee_injectable_gen/karee_injectable_gen.dart';
import 'package:karee_injectable_gen/src/models/field.dart';
import 'package:karee_injectable_gen/src/models/service_extension.dart';
import 'package:karee_injectable_gen/src/validators/field_validator.dart';
import 'package:source_gen/source_gen.dart';
import 'package:karee_inject/karee_inject.dart' show ServiceAnnotation;
import '../builder.dart' show VisitableElement;

class ServiceGenerator extends GeneratorForAnnotation<ServiceAnnotation> {
  List<ServiceExtension> extensions = [];

  @override
  void generateForAnnotatedElement(Element element, ConstantReader annotation, BuildStep buildStep) {
    print('\n\n\n#### GENERATOR FOR SERVICE ----- begin\n\n\n');
    print({
      #name: element.declaration?.name,
      #uri: element.source?.uri.toString(),
      #file: element.declaration?.getDisplayString(withNullability: false)
    });

    var visitor = VisitableElement();
    element.visitChildren(visitor);

    FieldValidator.validateMultipleFields(visitor.fields);

    var ext = ServiceExtension(
        fields: visitor.fields,
        fileName: element.source?.shortName ?? '',
        serviceClassName: element.declaration?.name ?? '',
        uri: element.source?.uri.toString() ?? '');
    writeExtensionIndex(ext);
  }

  void writeExtensionIndex(ServiceExtension ext) {
    extensions.add(ext);

    print(ext);
    Directory('lib/core/extensions').createSync(recursive: true);
    var f = File('lib/core/extensions.dart');

    var content = '''\n/// Genereated by Karee\n\n\n'''
        '''Map<String, dynamic> extensions = {\n''';
    var space = 0;
    extensions.forEach((e) {
      content = '''import 'extensions/extension_${e.fileName}' as e$space;\n'''
          '''$content'''
          '''\t'${e.serviceClassName}': e$space.\$extended${e.serviceClassName},\n''';
      space++;
    });

    content = '''$content\n};''';
    f.writeAsStringSync(content, mode: FileMode.write);
    extensions.forEach((e) => writeExtentionForService(e));
  }

  void writeExtentionForService(ServiceExtension ext) {
    print(ext);
    var f = File('lib/core/extensions/extension_${ext.fileName}');

    var content = '''import '${ext.uri}';\n\n'''
        '''/// Generated by Karee \n\n'''
        '''extension ${ext.serviceClassName}Extension on ${ext.serviceClassName} {\n'''
        '''\tvoid init(){''';
    var valueFields = ext.fields.where((field) => field.isPublic && (field.value != null)).toList();
    if (valueFields.isNotEmpty) {
      content = '''import 'package:karee_core/karee_core.dart';\n'''
          '''$content''';
    }

    valueFields.forEach((field) {
      content = '''$content'''
          '''\n\t\t${field.name} = ${getInitialValueForField(field)};''';
    });

    /// Because injectable fields through Autowired are only Services, we can
    /// insure that typer of current field will be in `extensions` (ServiceExtension)
    var autowiredFields = ext.fields.where((field) => field.isPublic && field.injectable).toList();

    if (autowiredFields.isNotEmpty) {
      content = '''import '../extensions.dart';\n'''
          '''$content''';
    }
    autowiredFields.forEach((field) {
      content = '''$content'''
          '''\n\t\t${field.name} = ${getInitialValueForField(field)};''';
    });

    content = '''$content'''
        '''\n\t}'''
        '''\n\t${ext.serviceClassName} get self {'''
        '''\n\t\tinit();'''
        '''\n\t\treturn this;'''
        '''\n\t}'''
        '''\n}\n\n'''
        '''final \_instance${ext.serviceClassName} = ${ext.serviceClassName}()..self;\n'''
        '''final \$extended${ext.serviceClassName} = () => _instance${ext.serviceClassName};\n''';
    f.writeAsStringSync(content, mode: FileMode.write);
  }

  dynamic getInitialValueForField(Field f) {
    if (f.injectable) {
      return "extensions['${f.type}']()";
    } else if (f.value != null) {
      switch (f.type) {
        case 'int':
        case 'double':
        case 'num':
        case 'String':
        case 'List':
        case 'bool':
          return "readConfig('${f.value}')";
      }
      if ({(int).toString(), (double).toString(), (num).toString(), (String).toString(), (List).toString()}
          .contains(f.type)) {}
    }
  }
}
